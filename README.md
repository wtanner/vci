# vci - voice compression identifier

This tool is used to identify the compression algorithm(s) used in a "black box" voice audio path. That is, it will determine the type of voice compression used over an unknown digital voice channel. This version is designed specifically to identify GSM 2/3/4G voice compression (Adaptive Multi-Rate, or AMR), but could easily be extended to other algorithms.

## Usage

The tool requires training a machine learning algorithm before it can attempt to identify an input sound file from an unknown voice channel. A short (few seconds) voice clip must be provided to generate the training and test vectors. The tool will crop it to 2 seconds and scale during preprocessing. There are many voice test wav files online these days. It should be voice, single channel (mono) and sampled at 8 kHz.

### Generate training and test vectors

1. move audio clip to "train.wav"
2. octave gen_training.m

This generates two directories, "test" and "training", and fills these with feature vectors (see Technical details section).

### Train the SVM classifier

1. ./vci.py -t -i train.wav -o class.pkl

This will fit the "training" feature vectors and determine the support vectors. The "test" feature vectors are then used to score the accuracy of the compression algorithm classifications (between 0 and 1). The classifier is saved to the file "class.pkl" as a serialized Python object.

### Identification

1. ./vci.py -i class.pkl -p ./test/AMR/1.wav

The output is the identified compression algorithm of the provided wav sample, using the trained classifier stored in "class.pkl". Note that the input wav file must be the same length as the training vectors, e.g. 16000 samples. This means it must have already been correlated or preprocessed in some way to remove any delay.

## Motivation

I was in the process of using a cellular voice network to conduct some tests, when I discovered I was not getting the results I expected. I then realized I had no way of knowing which voice compression algorithm was used by which carrier, and during which calls. This information is not readily available on a per-call basis. Thus, I had no way to control for this variable in over-the-air testing.

## Technical details

The tool uses a multi-class support vector machine (SVM), with a linear kernel, to discriminate between six distinct voice compression pathways:

1. PASSTHROUGH (no compression)
2. AMR (Full Rate 12.2kbps)
3. AMR102 (10.2kbps)
4. AMR795 (7.95kbps)
5. AMR67 (6.7kbps)
6. AMR59 (5.9kbps)

The feature vector is length 16000, and represents 2 seconds of normalized audio samples scaled between -1 and 1, sampled at 8 kHz. The training and test vectors are generated by sending a 16000 sample sound clip through each of the compression algorithms several hundred times. To account for unknown channel conditions that may affect the output of the voice compression algorithm, the following channel effects were added to each training and test feature vector:

1. Random delay (0-5 s)
2. Additive white gaussian noise (AWGN) with a signal-to-noise-ratio of 30dB
3. Random amplitude scaling, uniformly distributed between 50-100% full-scale

Using these parameters, I obtain a prediction accuracy of 99.8%. I used libsvm defaults and have done no further tweaking of the model parameters.

## Dependencies

1. Octave (tested on 3.6.4)
2. Python (tested on 2.7.5)
3. SciPy (tested on 0.12.1)
4. Scikit-learn (tested on 0.14)
5. 3GPP AMR reference implementation (TS 26.073 Rel-11), available at http://www.3gpp.org/ftp/Specs/archive/26_series/26.073/26073-b00.zip
